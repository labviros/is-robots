// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: power.proto

#ifndef PROTOBUF_power_2eproto__INCLUDED
#define PROTOBUF_power_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_power_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPowerInfoImpl();
void InitDefaultsPowerInfo();
inline void InitDefaults() {
  InitDefaultsPowerInfo();
}
}  // namespace protobuf_power_2eproto
namespace is {
namespace common {
class PowerInfo;
class PowerInfoDefaultTypeInternal;
extern PowerInfoDefaultTypeInternal _PowerInfo_default_instance_;
}  // namespace common
}  // namespace is
namespace is {
namespace common {

enum PowerInfo_BatteryType {
  PowerInfo_BatteryType_PB = 0,
  PowerInfo_BatteryType_NICD = 1,
  PowerInfo_BatteryType_NIMH = 2,
  PowerInfo_BatteryType_LIPO = 3,
  PowerInfo_BatteryType_PowerInfo_BatteryType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerInfo_BatteryType_PowerInfo_BatteryType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerInfo_BatteryType_IsValid(int value);
const PowerInfo_BatteryType PowerInfo_BatteryType_BatteryType_MIN = PowerInfo_BatteryType_PB;
const PowerInfo_BatteryType PowerInfo_BatteryType_BatteryType_MAX = PowerInfo_BatteryType_LIPO;
const int PowerInfo_BatteryType_BatteryType_ARRAYSIZE = PowerInfo_BatteryType_BatteryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PowerInfo_BatteryType_descriptor();
inline const ::std::string& PowerInfo_BatteryType_Name(PowerInfo_BatteryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PowerInfo_BatteryType_descriptor(), value);
}
inline bool PowerInfo_BatteryType_Parse(
    const ::std::string& name, PowerInfo_BatteryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PowerInfo_BatteryType>(
    PowerInfo_BatteryType_descriptor(), name, value);
}
enum PowerInfo_BatteryStatus {
  PowerInfo_BatteryStatus_UNKNOWN = 0,
  PowerInfo_BatteryStatus_CHARGING = 1,
  PowerInfo_BatteryStatus_DISCHARGING = 2,
  PowerInfo_BatteryStatus_CHARGED = 3,
  PowerInfo_BatteryStatus_NOT_CONNECTED = 4,
  PowerInfo_BatteryStatus_PowerInfo_BatteryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerInfo_BatteryStatus_PowerInfo_BatteryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerInfo_BatteryStatus_IsValid(int value);
const PowerInfo_BatteryStatus PowerInfo_BatteryStatus_BatteryStatus_MIN = PowerInfo_BatteryStatus_UNKNOWN;
const PowerInfo_BatteryStatus PowerInfo_BatteryStatus_BatteryStatus_MAX = PowerInfo_BatteryStatus_NOT_CONNECTED;
const int PowerInfo_BatteryStatus_BatteryStatus_ARRAYSIZE = PowerInfo_BatteryStatus_BatteryStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PowerInfo_BatteryStatus_descriptor();
inline const ::std::string& PowerInfo_BatteryStatus_Name(PowerInfo_BatteryStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PowerInfo_BatteryStatus_descriptor(), value);
}
inline bool PowerInfo_BatteryStatus_Parse(
    const ::std::string& name, PowerInfo_BatteryStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PowerInfo_BatteryStatus>(
    PowerInfo_BatteryStatus_descriptor(), name, value);
}
// ===================================================================

class PowerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:is.common.PowerInfo) */ {
 public:
  PowerInfo();
  virtual ~PowerInfo();

  PowerInfo(const PowerInfo& from);

  inline PowerInfo& operator=(const PowerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerInfo(PowerInfo&& from) noexcept
    : PowerInfo() {
    *this = ::std::move(from);
  }

  inline PowerInfo& operator=(PowerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerInfo* internal_default_instance() {
    return reinterpret_cast<const PowerInfo*>(
               &_PowerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PowerInfo* other);
  friend void swap(PowerInfo& a, PowerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PowerInfo& from);
  void MergeFrom(const PowerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PowerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PowerInfo_BatteryType BatteryType;
  static const BatteryType PB =
    PowerInfo_BatteryType_PB;
  static const BatteryType NICD =
    PowerInfo_BatteryType_NICD;
  static const BatteryType NIMH =
    PowerInfo_BatteryType_NIMH;
  static const BatteryType LIPO =
    PowerInfo_BatteryType_LIPO;
  static inline bool BatteryType_IsValid(int value) {
    return PowerInfo_BatteryType_IsValid(value);
  }
  static const BatteryType BatteryType_MIN =
    PowerInfo_BatteryType_BatteryType_MIN;
  static const BatteryType BatteryType_MAX =
    PowerInfo_BatteryType_BatteryType_MAX;
  static const int BatteryType_ARRAYSIZE =
    PowerInfo_BatteryType_BatteryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BatteryType_descriptor() {
    return PowerInfo_BatteryType_descriptor();
  }
  static inline const ::std::string& BatteryType_Name(BatteryType value) {
    return PowerInfo_BatteryType_Name(value);
  }
  static inline bool BatteryType_Parse(const ::std::string& name,
      BatteryType* value) {
    return PowerInfo_BatteryType_Parse(name, value);
  }

  typedef PowerInfo_BatteryStatus BatteryStatus;
  static const BatteryStatus UNKNOWN =
    PowerInfo_BatteryStatus_UNKNOWN;
  static const BatteryStatus CHARGING =
    PowerInfo_BatteryStatus_CHARGING;
  static const BatteryStatus DISCHARGING =
    PowerInfo_BatteryStatus_DISCHARGING;
  static const BatteryStatus CHARGED =
    PowerInfo_BatteryStatus_CHARGED;
  static const BatteryStatus NOT_CONNECTED =
    PowerInfo_BatteryStatus_NOT_CONNECTED;
  static inline bool BatteryStatus_IsValid(int value) {
    return PowerInfo_BatteryStatus_IsValid(value);
  }
  static const BatteryStatus BatteryStatus_MIN =
    PowerInfo_BatteryStatus_BatteryStatus_MIN;
  static const BatteryStatus BatteryStatus_MAX =
    PowerInfo_BatteryStatus_BatteryStatus_MAX;
  static const int BatteryStatus_ARRAYSIZE =
    PowerInfo_BatteryStatus_BatteryStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BatteryStatus_descriptor() {
    return PowerInfo_BatteryStatus_descriptor();
  }
  static inline const ::std::string& BatteryStatus_Name(BatteryStatus value) {
    return PowerInfo_BatteryStatus_Name(value);
  }
  static inline bool BatteryStatus_Parse(const ::std::string& name,
      BatteryStatus* value) {
    return PowerInfo_BatteryStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated float cell_voltage = 3;
  int cell_voltage_size() const;
  void clear_cell_voltage();
  static const int kCellVoltageFieldNumber = 3;
  float cell_voltage(int index) const;
  void set_cell_voltage(int index, float value);
  void add_cell_voltage(float value);
  const ::google::protobuf::RepeatedField< float >&
      cell_voltage() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_cell_voltage();

  // .google.protobuf.Duration uptime = 8;
  bool has_uptime() const;
  void clear_uptime();
  static const int kUptimeFieldNumber = 8;
  const ::google::protobuf::Duration& uptime() const;
  ::google::protobuf::Duration* release_uptime();
  ::google::protobuf::Duration* mutable_uptime();
  void set_allocated_uptime(::google::protobuf::Duration* uptime);

  // .google.protobuf.Duration autonomy = 9;
  bool has_autonomy() const;
  void clear_autonomy();
  static const int kAutonomyFieldNumber = 9;
  const ::google::protobuf::Duration& autonomy() const;
  ::google::protobuf::Duration* release_autonomy();
  ::google::protobuf::Duration* mutable_autonomy();
  void set_allocated_autonomy(::google::protobuf::Duration* autonomy);

  // float voltage = 1;
  void clear_voltage();
  static const int kVoltageFieldNumber = 1;
  float voltage() const;
  void set_voltage(float value);

  // float terminal_voltage = 2;
  void clear_terminal_voltage();
  static const int kTerminalVoltageFieldNumber = 2;
  float terminal_voltage() const;
  void set_terminal_voltage(float value);

  // float charge = 4;
  void clear_charge();
  static const int kChargeFieldNumber = 4;
  float charge() const;
  void set_charge(float value);

  // float capacity = 5;
  void clear_capacity();
  static const int kCapacityFieldNumber = 5;
  float capacity() const;
  void set_capacity(float value);

  // .is.common.PowerInfo.BatteryType type = 6;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::is::common::PowerInfo_BatteryType type() const;
  void set_type(::is::common::PowerInfo_BatteryType value);

  // .is.common.PowerInfo.BatteryStatus status = 7;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::is::common::PowerInfo_BatteryStatus status() const;
  void set_status(::is::common::PowerInfo_BatteryStatus value);

  // @@protoc_insertion_point(class_scope:is.common.PowerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > cell_voltage_;
  mutable int _cell_voltage_cached_byte_size_;
  ::google::protobuf::Duration* uptime_;
  ::google::protobuf::Duration* autonomy_;
  float voltage_;
  float terminal_voltage_;
  float charge_;
  float capacity_;
  int type_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_power_2eproto::TableStruct;
  friend void ::protobuf_power_2eproto::InitDefaultsPowerInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PowerInfo

// float voltage = 1;
inline void PowerInfo::clear_voltage() {
  voltage_ = 0;
}
inline float PowerInfo::voltage() const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.voltage)
  return voltage_;
}
inline void PowerInfo::set_voltage(float value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.voltage)
}

// float terminal_voltage = 2;
inline void PowerInfo::clear_terminal_voltage() {
  terminal_voltage_ = 0;
}
inline float PowerInfo::terminal_voltage() const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.terminal_voltage)
  return terminal_voltage_;
}
inline void PowerInfo::set_terminal_voltage(float value) {
  
  terminal_voltage_ = value;
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.terminal_voltage)
}

// repeated float cell_voltage = 3;
inline int PowerInfo::cell_voltage_size() const {
  return cell_voltage_.size();
}
inline void PowerInfo::clear_cell_voltage() {
  cell_voltage_.Clear();
}
inline float PowerInfo::cell_voltage(int index) const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.cell_voltage)
  return cell_voltage_.Get(index);
}
inline void PowerInfo::set_cell_voltage(int index, float value) {
  cell_voltage_.Set(index, value);
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.cell_voltage)
}
inline void PowerInfo::add_cell_voltage(float value) {
  cell_voltage_.Add(value);
  // @@protoc_insertion_point(field_add:is.common.PowerInfo.cell_voltage)
}
inline const ::google::protobuf::RepeatedField< float >&
PowerInfo::cell_voltage() const {
  // @@protoc_insertion_point(field_list:is.common.PowerInfo.cell_voltage)
  return cell_voltage_;
}
inline ::google::protobuf::RepeatedField< float >*
PowerInfo::mutable_cell_voltage() {
  // @@protoc_insertion_point(field_mutable_list:is.common.PowerInfo.cell_voltage)
  return &cell_voltage_;
}

// float charge = 4;
inline void PowerInfo::clear_charge() {
  charge_ = 0;
}
inline float PowerInfo::charge() const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.charge)
  return charge_;
}
inline void PowerInfo::set_charge(float value) {
  
  charge_ = value;
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.charge)
}

// float capacity = 5;
inline void PowerInfo::clear_capacity() {
  capacity_ = 0;
}
inline float PowerInfo::capacity() const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.capacity)
  return capacity_;
}
inline void PowerInfo::set_capacity(float value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.capacity)
}

// .is.common.PowerInfo.BatteryType type = 6;
inline void PowerInfo::clear_type() {
  type_ = 0;
}
inline ::is::common::PowerInfo_BatteryType PowerInfo::type() const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.type)
  return static_cast< ::is::common::PowerInfo_BatteryType >(type_);
}
inline void PowerInfo::set_type(::is::common::PowerInfo_BatteryType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.type)
}

// .is.common.PowerInfo.BatteryStatus status = 7;
inline void PowerInfo::clear_status() {
  status_ = 0;
}
inline ::is::common::PowerInfo_BatteryStatus PowerInfo::status() const {
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.status)
  return static_cast< ::is::common::PowerInfo_BatteryStatus >(status_);
}
inline void PowerInfo::set_status(::is::common::PowerInfo_BatteryStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:is.common.PowerInfo.status)
}

// .google.protobuf.Duration uptime = 8;
inline bool PowerInfo::has_uptime() const {
  return this != internal_default_instance() && uptime_ != NULL;
}
inline const ::google::protobuf::Duration& PowerInfo::uptime() const {
  const ::google::protobuf::Duration* p = uptime_;
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.uptime)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* PowerInfo::release_uptime() {
  // @@protoc_insertion_point(field_release:is.common.PowerInfo.uptime)
  
  ::google::protobuf::Duration* temp = uptime_;
  uptime_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* PowerInfo::mutable_uptime() {
  
  if (uptime_ == NULL) {
    uptime_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:is.common.PowerInfo.uptime)
  return uptime_;
}
inline void PowerInfo::set_allocated_uptime(::google::protobuf::Duration* uptime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(uptime_);
  }
  if (uptime) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(uptime)->GetArena();
    if (message_arena != submessage_arena) {
      uptime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uptime, submessage_arena);
    }
    
  } else {
    
  }
  uptime_ = uptime;
  // @@protoc_insertion_point(field_set_allocated:is.common.PowerInfo.uptime)
}

// .google.protobuf.Duration autonomy = 9;
inline bool PowerInfo::has_autonomy() const {
  return this != internal_default_instance() && autonomy_ != NULL;
}
inline const ::google::protobuf::Duration& PowerInfo::autonomy() const {
  const ::google::protobuf::Duration* p = autonomy_;
  // @@protoc_insertion_point(field_get:is.common.PowerInfo.autonomy)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* PowerInfo::release_autonomy() {
  // @@protoc_insertion_point(field_release:is.common.PowerInfo.autonomy)
  
  ::google::protobuf::Duration* temp = autonomy_;
  autonomy_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* PowerInfo::mutable_autonomy() {
  
  if (autonomy_ == NULL) {
    autonomy_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:is.common.PowerInfo.autonomy)
  return autonomy_;
}
inline void PowerInfo::set_allocated_autonomy(::google::protobuf::Duration* autonomy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(autonomy_);
  }
  if (autonomy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(autonomy)->GetArena();
    if (message_arena != submessage_arena) {
      autonomy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, autonomy, submessage_arena);
    }
    
  } else {
    
  }
  autonomy_ = autonomy;
  // @@protoc_insertion_point(field_set_allocated:is.common.PowerInfo.autonomy)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace is

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::is::common::PowerInfo_BatteryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::is::common::PowerInfo_BatteryType>() {
  return ::is::common::PowerInfo_BatteryType_descriptor();
}
template <> struct is_proto_enum< ::is::common::PowerInfo_BatteryStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::is::common::PowerInfo_BatteryStatus>() {
  return ::is::common::PowerInfo_BatteryStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_power_2eproto__INCLUDED
